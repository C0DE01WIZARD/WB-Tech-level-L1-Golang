// 6.Реализовать все возможные способы остановки выполнения горутины.
// !!! Способы остановки выполнения горутин в языке программирования Go нужны для того, чтобы корректно завершить работу горутин в различных ситуациях.
/* Реализуем 5 способов завершения горутин:
1) Завершение по достижения точки возврата
2) Завершение по отправке сигнала на канал
3) Завершение с сигналом отменой контекста
4) Завершение по таймауту
5) Немедлеенное завершение, с вызовом функции runtime.Goexit()
*/

package main

import (
    "fmt"     
    "time"      // Импорт пакета для работы со временем
    "runtime"   // Импорт пакета для взаимодействия с рантаймом Go
    "context"   // Импорт пакета для работы с контекстами
    "sync"      // Импорт пакета для синхронизации горутин
)

func main() {
	fmt.Println("Exercise06")
    var waitgroup sync.WaitGroup  // Объявляем переменную waitgroup c типом sync.WaitGroup для группы ожидания завершения горутин

	// 1) Завершение по достижения точки возврата
    // Добавляем горутину в группу ожидания
    waitgroup.Add(1)  // Увеличиваем счетчик группы ожидания на 1
    go func() {
        defer waitgroup.Done()  // По завершении горутины уменьшаем счетчик до 0, waitgroup.Wait() разблокируется.
        defer fmt.Println("Горутина 'по достижения точки возврата' завершена.") //Вывод в консоли сообщения о завершении горутины
        return  // Возврат из функции останавливает горутину
    }()
	
	// 2) Завершение по отправке сигнала на канал
    done := make(chan struct{})  // Создание канала для сигналов
    waitgroup.Add(1)  // Увеличиваем счетчик группы ожидания на 1
    go func() {
        defer waitgroup.Done() // По завершении горутины уменьшаем счетчик до 0, waitgroup.Wait() разблокируется.
        defer fmt.Println("Горутина 'по отправке сигнала на канал' завершена.")//Вывод в консоли сообщения о завершении горутины
        <-done  // Ожидание сигнала на канале
    }()
    done <- struct{}{}  // Отправка сигнала в канал

	// 3) Завершение с сигналом отменой контекста
    ctx, cancel := context.WithCancel(context.Background())  // Создание контекста с возможностью отмены
    waitgroup.Add(1)  // Увеличиваем счетчик группы ожидания на 1
    go func() {
        defer waitgroup.Done() // По завершении горутины уменьшаем счетчик до 0, waitgroup.Wait() разблокируется.
        defer fmt.Println("Горутина 'с сигналом отменой контекста' завершена.")//Вывод в консоли сообщения о завершении горутины
        <-ctx.Done()  // Ожидание сигнала о завершении контекста
    }()
    cancel()  // Отправка сигнала об отмене контекста

	// 4) Завершение по таймауту
    waitgroup.Add(1)  // Увеличиваем счетчик группы ожидания на 1
    go func() {
        defer waitgroup.Done() // По завершении горутины уменьшаем счетчик до 0, waitgroup.Wait() разблокируется.
        defer fmt.Println("Горутина 'по таймауту' завершена.")//Вывод в консоли сообщения о завершении горутины
        <-time.After(5*time.Second)  // Ожидание таймаута в 5 секунд
    }()
	
	// 5) Немедлеенное завершение, с вызовом функции runtime.Goexit()
    waitgroup.Add(1)  // Увеличиваем счетчик группы ожидания на 1
    go func() {
        defer waitgroup.Done() // По завершении горутины уменьшаем счетчик до 0, waitgroup.Wait() разблокируется.
        defer fmt.Println("Горутина 'с вызовом функции runtime.Goexit()' завершена.")//Вывод в консоли сообщения о завершении горутины
        runtime.Goexit()  // Вызов функции для остановки горутины. !!! Завершает только одну горутину, в которой вызвана.
    }()

    // Ожидаем завершения всех горутин
    waitgroup.Wait()  // Блокировка до тех пор, пока счетчик группы ожидания не станет равным 0
}