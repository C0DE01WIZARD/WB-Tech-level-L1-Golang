1) Какой самый эффективный способ конкатенации строк?

Ответ: В Go самый эффективный способ конкатенации строк — использование strings.Builder, так как он минимизирует количество аллокаций памяти (это процесс выделения памяти для переменных и структур данных во время выполнения программы: стек и куча) и копирований. 

2) Что такое интерфейсы, как они применяются в Go?

Ответ: Интерфейсы в Go — это абстрактный тип, который определяет набор методов, которые должны быть реализованы в типе. Они предоставляют способ определения поведения, которое должно быть реализовано структурами или другими типами, без необходимости знать конкретные детали этих типов.
Интерфейсы позволяют определять функции, которые не привязаны к конкретной реализации. 

3) Чем отличаются RWMutex от Mutex?

Ответ: 
RWMutex и Mutex — это типы горутин в Go, которые используются для синхронизации доступа к общим ресурсам.
RWMutex применяется со структурами, безопасными для параллельного чтения, но небезопасными для записи. 
RWMutex позволяет не блокировать чтение, если в данный момент не идёт запись. 
В отличие от Mutex, RWMutex позволяет нескольким потокам одновременно читать данные, что может улучшить производительность, если большинство операций являются чтением. 

4) Чем отличаются буферизированные и не буферизированные каналы?

Ответ: При отправке сообщения в небуферизированный канал поток блокируется и ждёт, когда кто-то извлечёт сообщение. В буферизированном канале поток блокируется когда буфер заполнен полностью

5) Какой размер у структуры struct{}{}?
 
s := struct{}{}
fmt.Printf("%v\n", unsafe.Sizeof(s))

Ответ: >0
6. Есть ли в Go перегрузка методов или операторов?

В Go нет перегрузки методов и функций. Предлагается просто давать разные имена методам и функциям.

7. В какой последовательности будут выведены элементы map[int]int?

Пример:


m[0]=1
m[1]=124
m[2]=281 Рандомно
8. В чем разница make и new?

> - `make` используется для создания `slice, map, chan`, `new` - для всего
> - `make` возвращает сам объект, `new` выделяет память и возвращает указатель на созданный объект
9. Сколько существует способов задать переменную типа slice или map?

var first []string
second := []string{}
fourth := make([]string, 0)
third := new([]string)


var first map[int]int
second := map[string]int{}
fourth := make(map[string]int)
third := new(map[string]int)


10. Что выведет данная программа и почему?

func update(p *int) {
b := 2
p = &b
}

func main() {
var (
a = 1
p = &a
)

fmt.Println(*p)
update(p)
fmt.Println(*p)
}


> 1 1\
> В `update()` меняется не значение по указателю, а значение самого указателя, которое остаётся в локальной видимости 
11. Что выведет данная программа и почему?

```go
func main() {
wg := sync.WaitGroup{}
for i := 0; i < 5; i++ {
wg.Add(1)
go func(wg sync.WaitGroup, i int) {
fmt.Println(i)
wg.Done()
}(wg, i)
}
wg.Wait()
fmt.Println("exit")
}
```

> 0..4 в рандомном порядке, далее deadlock, т.к. в горутину передан `WaitGroup`, а не указатель на него
12. Что выведет данная программа и почему?

```go
func main() {
n := 0
if true {
n := 1
n++
}
fmt.Println(n)
}
```

> 0\
> В блоке if создается локальная переменная 
13. Что выведет данная программа и почему?

```go
func someAction(v []int8, b int8) {
v[0] = 100
v = append(v, b)
}

func main() {
var a = []int8{1, 2, 3, 4, 5}
someAction(a, 6)
fmt.Println(a)
}
```

> [100 2 3 4 5]\
> При append создается новый slice, не затронут оригинальный slice

14. Что выведет данная программа и почему?

```go
func main() {
slice := []string{"a", "a"}

func(slice []string) {
slice = append(slice, "a")
slice[0] = "b"
slice[1] = "b"
fmt.Print(slice)
}(slice)
fmt.Print(slice)
}
```

> [b b a][a a]\
> slice в анонимной функции перекрывает slice в main, обновляется и выводится [b b a], slice в main не изменялся - выводится [a a]

